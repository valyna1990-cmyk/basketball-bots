#!/usr/bin/env python3
# /opt/basketball-bots/bots/enhanced_second_half_over_bot.py

import asyncio
import logging
import sys
import os
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import aiohttp
import pandas as pd
import numpy as np
import psycopg2
from psycopg2.extras import RealDictCursor
import redis

sys.path.append('/opt/basketball-bots')

from config.settings import DATABASE_URL, REDIS_URL, LOG_LEVEL

class EnhancedSecondHalfOverBot:
    def __init__(self):
        self.bot_name = "Enhanced Second Half Over"
        self.bot_id = "ENHANCED_H2_OVER_001"
        
        # –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
        self.config = {
            'confidence_threshold': 0.65,
            'max_daily_bets': 6,
            'stake_range': [0.015, 0.045],
            'deviation_range': [-15, -3],  # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
            'target_leagues': {
                'primary': ['Euroleague', 'Spain ACB', 'Germany BBL', 'China CBA'],
                'secondary': ['France Pro A', 'Italy Lega', 'Israel Winner League'],
                'experimental': ['Turkey BSL', 'Greece Basket League']
            },
            'update_interval': 120,  # —Å–µ–∫—É–Ω–¥—ã (—Ä–µ–∂–µ, —Ç.–∫. —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ halftime)
            'min_odds': 1.80
        }
        
        # –õ–∏–≥-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.league_params = {
            'Euroleague': {'confidence': 0.65, 'deviation': [-14, -4]},
            'China CBA': {'confidence': 0.62, 'deviation': [-18, -2]},
            'Spain ACB': {'confidence': 0.68, 'deviation': [-13, -3]},
            'Germany BBL': {'confidence': 0.66, 'deviation': [-12, -3]},
            'default': {'confidence': 0.65, 'deviation': [-15, -3]}
        }
        
        self.setup_logging()
        self.db_conn = None
        self.redis_client = None
        
    def setup_logging(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        log_dir = "/opt/basketball-bots/logs"
        os.makedirs(log_dir, exist_ok=True)
        
        logging.basicConfig(
            level=getattr(logging, LOG_LEVEL),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(f"{log_dir}/enhanced_h2_over_bot.log"),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(self.bot_name)

    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞"""
        try:
            self.logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Enhanced Second Half Over Bot...")
            
            self.db_conn = psycopg2.connect(DATABASE_URL)
            self.redis_client = redis.from_url(REDIS_URL)
            
            await self.create_tables()
            
            self.logger.info("‚úÖ Enhanced Second Half Over Bot –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            return False

    async def create_tables(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –≤ –ë–î"""
        try:
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS enhanced_h2_over_signals (
                        id SERIAL PRIMARY KEY,
                        match_id VARCHAR(100) NOT NULL,
                        home_team VARCHAR(100),
                        away_team VARCHAR(100),
                        league VARCHAR(50),
                        halftime_score VARCHAR(20),
                        deviation_from_avg FLOAT,
                        prediction_type VARCHAR(10),
                        confidence FLOAT,
                        predicted_total FLOAT,
                        recommended_stake FLOAT,
                        created_at TIMESTAMP DEFAULT NOW(),
                        status VARCHAR(20) DEFAULT 'active'
                    );

                    CREATE TABLE IF NOT EXISTS enhanced_h2_over_performance (
                        id SERIAL PRIMARY KEY,
                        signal_id INTEGER REFERENCES enhanced_h2_over_signals(id),
                        second_half_total FLOAT,
                        actual_result VARCHAR(10),
                        profit_loss FLOAT,
                        settled_at TIMESTAMP,
                        created_at TIMESTAMP DEFAULT NOW()
                    );
                """)
                self.db_conn.commit()
                self.logger.info("‚úÖ –¢–∞–±–ª–∏—Ü—ã –ë–î —Å–æ–∑–¥–∞–Ω—ã/–ø—Ä–æ–≤–µ—Ä–µ–Ω—ã")
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü: {e}")

    async def fetch_halftime_matches(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–∞—Ç—á–µ–π, –¥–æ—Å—Ç–∏–≥—à–∏—Ö –ø–µ—Ä–µ—Ä—ã–≤–∞"""
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ - API –∑–∞–ø—Ä–æ—Å –∫ –∏—Å—Ç–æ—á–Ω–∏–∫—É –¥–∞–Ω–Ω—ã—Ö
            mock_matches = [
                {
                    'id': 'ACB_001',
                    'home_team': 'Barcelona',
                    'away_team': 'Real Madrid',
                    'league': 'Spain ACB',
                    'start_time': datetime.now() - timedelta(hours=1),
                    'halftime_score': '45-42',
                    'current_quarter': 'HALFTIME',
                    'q1_score': '22-20',
                    'q2_score': '23-22'
                },
                {
                    'id': 'CBA_002',
                    'home_team': 'Liaoning',
                    'away_team': 'Guangzhou',
                    'league': 'China CBA', 
                    'start_time': datetime.now() - timedelta(hours=1),
                    'halftime_score': '48-55',
                    'current_quarter': 'HALFTIME',
                    'q1_score': '25-28',
                    'q2_score': '23-27'
                }
            ]
            
            # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ª–∏–≥–∞–º
            all_target_leagues = []
            for category in self.config['target_leagues'].values():
                all_target_leagues.extend(category)
                
            filtered_matches = [
                match for match in mock_matches 
                if match['league'] in all_target_leagues 
                and match.get('halftime_score') is not None
            ]
            
            self.logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(filtered_matches)} –º–∞—Ç—á–µ–π –Ω–∞ –ø–µ—Ä–µ—Ä—ã–≤–µ")
            return filtered_matches
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–∞—Ç—á–µ–π: {e}")
            return []

    async def get_league_average(self, league: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ —Ç–æ—Ç–∞–ª–∞ –ø–µ—Ä–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω—ã –¥–ª—è –ª–∏–≥–∏"""
        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ - –∏–∑ –±–∞–∑—ã –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        league_averages = {
            'Euroleague': 78.5,
            'Spain ACB': 76.2,
            'Germany BBL': 77.8,
            'China CBA': 85.3,
            'France Pro A': 75.9,
            'Italy Lega': 76.5,
            'Israel Winner League': 79.2,
            'Turkey BSL': 78.7,
            'Greece Basket League': 77.3
        }
        return league_averages.get(league, 78.0)

    async def calculate_halftime_deviation(self, match: Dict) -> Optional[float]:
        """–†–∞—Å—á–µ—Ç –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ —Ç–æ—Ç–∞–ª–∞ –ª–∏–≥–∏"""
        try:
            halftime_score = match.get('halftime_score')
            if not halftime_score:
                return None
                
            # –ü–∞—Ä—Å–∏–º —Å—á–µ—Ç (—Ñ–æ—Ä–º–∞—Ç "45-42")
            home_score, away_score = map(int, halftime_score.split('-'))
            total_score = home_score + away_score
            
            league_avg = await self.get_league_average(match['league'])
            deviation = total_score - league_avg
            
            self.logger.debug(f"üìä –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –¥–ª—è {match['id']}: {deviation} (—Ç–æ—Ç–∞–ª: {total_score}, —Å—Ä–µ–¥–Ω–µ–µ: {league_avg})")
            return deviation
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è: {e}")
            return None

    async def calculate_enhanced_confidence(self, match: Dict, deviation: float) -> float:
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ —Ñ–∞–∫—Ç–æ—Ä–∞–º–∏"""
        try:
            base_confidence = 0.7
            
            # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
            deviation_factor = abs(deviation) * 0.01
            
            # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ª–∏–≥–∏
            league_strength = await self.get_league_strength(match['league'])
            
            # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–º–ø–∞ –∏–≥—Ä—ã
            pace_factor = await self.analyze_game_pace(match)
            
            # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
            enhanced_confidence = (
                base_confidence * 0.4 +
                deviation_factor * 0.3 + 
                league_strength * 0.2 +
                pace_factor * 0.1
            )
            
            return min(enhanced_confidence, 0.95)
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏: {e}")
            return 0.0

    async def get_league_strength(self, league: str) -> float:
        """–°–∏–ª–∞ –ª–∏–≥–∏ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏"""
        strength_map = {
            'Euroleague': 0.9,
            'Spain ACB': 0.85,
            'China CBA': 0.8,
            'Germany BBL': 0.75,
            'France Pro A': 0.7,
            'Italy Lega': 0.7,
            'Israel Winner League': 0.65,
            'Turkey BSL': 0.6,
            'Greece Basket League': 0.6
        }
        return strength_map.get(league, 0.5)

    async def analyze_game_pace(self, match: Dict) -> float:
        """–ê–Ω–∞–ª–∏–∑ —Ç–µ–º–ø–∞ –∏–≥—Ä—ã"""
        try:
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–º–ø –ø–æ —á–µ—Ç–≤–µ—Ä—Ç—è–º
            q1_score = match.get('q1_score', '0-0')
            q2_score = match.get('q2_score', '0-0')
            
            q1_home, q1_away = map(int, q1_score.split('-'))
            q2_home, q2_away = map(int, q2_score.split('-'))
            
            q1_total = q1_home + q1_away
            q2_total = q2_home + q2_away
            
            # –¢–µ–º–ø –≤—Ç–æ—Ä–æ–π —á–µ—Ç–≤–µ—Ä—Ç–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–≤–æ–π
            if q1_total > 0:
                pace_ratio = q2_total / q1_total
            else:
                pace_ratio = 1.0
                
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
            pace_confidence = min(pace_ratio, 1.3)  # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–≤–µ—Ä—Ö—É
            
            return pace_confidence * 0.5  # –í–µ—Å 50% –≤ –æ–±—â–µ–º —Ñ–∞–∫—Ç–æ—Ä–µ
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–º–ø–∞: {e}")
            return 0.5

    async def get_league_parameters(self, league: str) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ª–∏–≥–∏"""
        return self.league_params.get(league, self.league_params['default'])

    async def generate_prediction(self, match: Dict) -> Optional[Dict]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –¥–ª—è –º–∞—Ç—á–∞"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –ª–∏–≥-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            league_params = await self.get_league_parameters(match['league'])
            
            # –†–∞—Å—á–µ—Ç –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
            deviation = await self.calculate_halftime_deviation(match)
            if deviation is None:
                return None
                
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è
            if not (league_params['deviation'][0] <= deviation <= league_params['deviation'][1]):
                return None
                
            # –†–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
            confidence = await self.calculate_enhanced_confidence(match, deviation)
            
            if confidence >= league_params['confidence']:
                # –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ–º —Ç–æ—Ç–∞–ª –≤—Ç–æ—Ä–æ–π –ø–æ–ª–æ–≤–∏–Ω—ã
                halftime_total = sum(map(int, match['halftime_score'].split('-')))
                predicted_second_half = halftime_total * 1.15  # –≠–º–ø–∏—Ä–∏—á–µ—Å–∫–∞—è —Ñ–æ—Ä–º—É–ª–∞
                
                prediction = {
                    'match_id': match['id'],
                    'prediction_type': 'OVER',
                    'confidence': round(confidence, 3),
                    'deviation': round(deviation, 1),
                    'predicted_total': round(predicted_second_half, 1),
                    'time_window': 'Halftime - Q3 3:00',
                    'expected_value': round(confidence * 0.75, 3)
                }
                return prediction
                
            return None
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è: {e}")
            return None

    async def calculate_dynamic_stake(self, confidence: float, league: str) -> float:
        """–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç —Å—Ç–∞–≤–∫–∏ —Å —É—á–µ—Ç–æ–º –ª–∏–≥–∏"""
        base_stake = 0.02
        
        # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
        confidence_multiplier = confidence / 0.7
        
        # –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ —Å–∏–ª—É –ª–∏–≥–∏
        league_strength = await self.get_league_strength(league)
        league_multiplier = 0.5 + league_strength  # 0.5-1.4 –¥–∏–∞–ø–∞–∑–æ–Ω
        
        stake = base_stake * confidence_multiplier * league_multiplier
        stake = max(self.config['stake_range'][0], 
                   min(stake, self.config['stake_range'][1]))
        
        return round(stake, 4)

    async def save_signal(self, match: Dict, prediction: Dict, stake: float):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –≤ –ë–î"""
        try:
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO enhanced_h2_over_signals 
                    (match_id, home_team, away_team, league, halftime_score,
                     deviation_from_avg, prediction_type, confidence, predicted_total, recommended_stake)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    match['id'],
                    match['home_team'],
                    match['away_team'],
                    match['league'],
                    match['halftime_score'],
                    prediction['deviation'],
                    prediction['prediction_type'],
                    prediction['confidence'],
                    prediction['predicted_total'],
                    stake
                ))
                self.db_conn.commit()
                
            self.logger.info(f"üíæ –°–∏–≥–Ω–∞–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω –¥–ª—è {match['home_team']} vs {match['away_team']}")
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞: {e}")

    async def send_telegram_alert(self, match: Dict, prediction: Dict, stake: float):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram"""
        try:
            message = f"""
üéØ *ENHANCED SECOND HALF OVER SIGNAL*

üèÄ *–ú–∞—Ç—á:* {match['home_team']} vs {match['away_team']}
üìä *–õ–∏–≥–∞:* {match['league']}
‚öñÔ∏è *–ü–µ—Ä–µ—Ä—ã–≤:* {match['halftime_score']}
üìà *–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ:* {prediction['deviation']} –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ
üéØ *–ü—Ä–æ–≥–Ω–æ–∑:* OVER {prediction['predicted_total']} –≤–æ –≤—Ç–æ—Ä–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
‚úÖ *–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å:* {prediction['confidence']:.1%}
üí∞ *–°—Ç–∞–≤–∫–∞:* {stake:.1%} –±–∞–Ω–∫—Ä–æ–ª–ª–∞
‚è∞ *–û–∫–Ω–æ:* {prediction['time_window']}

ü§ñ *–ë–æ—Ç:* {self.bot_name}
            """
            
            self.logger.info(f"üì§ Telegram alert: {message}")
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram: {e}")

    async def check_daily_limit(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ —Å—Ç–∞–≤–æ–∫"""
        try:
            today = datetime.now().date()
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    SELECT COUNT(*) as bet_count 
                    FROM enhanced_h2_over_signals 
                    WHERE DATE(created_at) = %s AND status = 'active'
                """, (today,))
                result = cursor.fetchone()
                
            current_bets = result[0] if result else 0
            limit_ok = current_bets < self.config['max_daily_bets']
            
            if not limit_ok:
                self.logger.warning(f"‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç: {current_bets}/{self.config['max_daily_bets']}")
                
            return limit_ok
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–º–∏—Ç–∞: {e}")
            return False

    async def process_matches(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ç—á–µ–π"""
        try:
            if not await self.check_daily_limit():
                return
                
            matches = await self.fetch_halftime_matches()
            
            signals_generated = 0
            for match in matches:
                try:
                    prediction = await self.generate_prediction(match)
                    
                    if prediction:
                        stake = await self.calculate_dynamic_stake(
                            prediction['confidence'], match['league']
                        )
                        
                        await self.save_signal(match, prediction, stake)
                        await self.send_telegram_alert(match, prediction, stake)
                        
                        signals_generated += 1
                        self.logger.info(f"‚úÖ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–∏–≥–Ω–∞–ª –¥–ª—è {match['home_team']} vs {match['away_team']}")
                        
                except Exception as e:
                    self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ç—á–∞ {match.get('id')}: {e}")
                    continue
            
            self.logger.info(f"üìà –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {signals_generated}")
            
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ç—á–µ–π: {e}")

    async def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –±–æ—Ç–∞"""
        self.logger.info("üéØ –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ Enhanced Second Half Over Bot")
        
        while True:
            try:
                start_time = datetime.now()
                
                await self.process_matches()
                
                execution_time = (datetime.now() - start_time).total_seconds()
                self.logger.debug(f"‚è±Ô∏è –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ü–∏–∫–ª–∞: {execution_time:.2f}—Å")
                
                await asyncio.sleep(self.config['update_interval'])
                
            except KeyboardInterrupt:
                self.logger.info("üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
                break
            except Exception as e:
                self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {e}")
                await asyncio.sleep(30)

    async def shutdown(self):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã"""
        try:
            self.logger.info("üî¥ –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã Enhanced Second Half Over Bot...")
            
            if self.db_conn:
                self.db_conn.close()
                
            self.logger.info("‚úÖ Enhanced Second Half Over Bot –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã: {e}")

async def main():
    bot = EnhancedSecondHalfOverBot()
    
    try:
        if not await bot.initialize():
            sys.exit(1)
            
        await bot.run()
        
    except KeyboardInterrupt:
        bot.logger.info("üõë –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        bot.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        await bot.shutdown()

if __name__ == "__main__":
    asyncio.run(main())
