#!/usr/bin/env python3
# /opt/basketball-bots/bots/ml_third_quarter_over_bot.py

import asyncio
import logging
import sys
import os
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import aiohttp
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
import psycopg2
from psycopg2.extras import RealDictCursor
import redis

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –¥–ª—è –∏–º–ø–æ—Ä—Ç–æ–≤
sys.path.append('/opt/basketball-bots')

from config.settings import DATABASE_URL, REDIS_URL, LOG_LEVEL

class MLThirdQuarterOverBot:
    def __init__(self):
        self.bot_name = "ML Third Quarter Over"
        self.bot_id = "ML_Q3_OVER_001"
        
        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.config = {
            'confidence_threshold': 0.67,
            'max_daily_bets': 8,
            'stake_range': [0.02, 0.06],
            'target_leagues': ["China CBA", "Euroleague", "Australia NBL", "Israel Winner League"],
            'update_interval': 60,  # —Å–µ–∫—É–Ω–¥—ã
            'min_odds': 1.85
        }
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–∞
        self.setup_logging()
        
        # –ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        self.db_conn = None
        self.redis_client = None
        
        # ML –º–æ–¥–µ–ª—å
        self.model = None
        self.model_version = "1.0"
        
    def setup_logging(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        log_dir = "/opt/basketball-bots/logs"
        os.makedirs(log_dir, exist_ok=True)
        
        logging.basicConfig(
            level=getattr(logging, LOG_LEVEL),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(f"{log_dir}/ml_q3_over_bot.log"),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(self.bot_name)

    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞"""
        try:
            self.logger.info("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML Third Quarter Over Bot...")
            
            # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL
            self.db_conn = psycopg2.connect(DATABASE_URL)
            self.logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
            
            # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis
            self.redis_client = redis.from_url(REDIS_URL)
            self.logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
            
            # –ó–∞–≥—Ä—É–∑–∫–∞ ML –º–æ–¥–µ–ª–∏
            await self.load_ml_model()
            
            # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            await self.create_tables()
            
            self.logger.info("‚úÖ ML Third Quarter Over Bot –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            return False

    async def load_ml_model(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ ML –º–æ–¥–µ–ª–∏"""
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –∑–∞–≥—Ä—É–∑–∫–∞ –æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏
            self.model = RandomForestClassifier(
                n_estimators=100,
                max_depth=10,
                random_state=42
            )
            self.logger.info("‚úÖ ML –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ML –º–æ–¥–µ–ª–∏: {e}")

    async def create_tables(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–±–ª–∏—Ü –≤ –ë–î"""
        try:
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS ml_q3_over_signals (
                        id SERIAL PRIMARY KEY,
                        match_id VARCHAR(100) NOT NULL,
                        home_team VARCHAR(100),
                        away_team VARCHAR(100),
                        league VARCHAR(50),
                        prediction_type VARCHAR(10),
                        confidence FLOAT,
                        predicted_line FLOAT,
                        recommended_stake FLOAT,
                        created_at TIMESTAMP DEFAULT NOW(),
                        status VARCHAR(20) DEFAULT 'active'
                    );
                    
                    CREATE TABLE IF NOT EXISTS ml_q3_over_performance (
                        id SERIAL PRIMARY KEY,
                        signal_id INTEGER REFERENCES ml_q3_over_signals(id),
                        actual_result VARCHAR(10),
                        profit_loss FLOAT,
                        settled_at TIMESTAMP,
                        created_at TIMESTAMP DEFAULT NOW()
                    );
                """)
                self.db_conn.commit()
                self.logger.info("‚úÖ –¢–∞–±–ª–∏—Ü—ã –ë–î —Å–æ–∑–¥–∞–Ω—ã/–ø—Ä–æ–≤–µ—Ä–µ–Ω—ã")
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü: {e}")

    async def fetch_live_matches(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –º–∞—Ç—á–µ–π"""
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª –±—ã API –∑–∞–ø—Ä–æ—Å
            # –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
            mock_matches = [
                {
                    'id': 'CBA_001',
                    'home_team': 'Guangdong Tigers',
                    'away_team': 'Beijing Ducks', 
                    'league': 'China CBA',
                    'start_time': datetime.now() + timedelta(hours=2),
                    'q1_score': '25-24',
                    'q2_score': '52-50',
                    'current_quarter': 'HALFTIME'
                },
                {
                    'id': 'EURO_001',
                    'home_team': 'Real Madrid',
                    'away_team': 'Barcelona',
                    'league': 'Euroleague',
                    'start_time': datetime.now() + timedelta(hours=1),
                    'q1_score': '28-26',
                    'q2_score': '55-52',
                    'current_quarter': 'HALFTIME'
                }
            ]
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ —Ü–µ–ª–µ–≤—ã–º –ª–∏–≥–∞–º
            filtered_matches = [
                match for match in mock_matches 
                if match['league'] in self.config['target_leagues']
            ]
            
            self.logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(filtered_matches)} –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –º–∞—Ç—á–µ–π")
            return filtered_matches
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–∞—Ç—á–µ–π: {e}")
            return []

    async def extract_features(self, match: Dict) -> Optional[List[float]]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è ML –º–æ–¥–µ–ª–∏"""
        try:
            features = []
            
            # –ü—Ä–∏–∑–Ω–∞–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–∑–∞–≥–ª—É—à–∫–∏)
            features.extend([
                0.75,  # scoring_momentum_q2
                0.68,  # defensive_efficiency  
                1.02,  # pace_factor
                0.81,  # home_advantage
                0.72,  # recent_form
            ])
            
            return features
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: {e}")
            return None

    async def generate_prediction(self, match: Dict) -> Optional[Dict]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è"""
        try:
            features = await self.extract_features(match)
            if not features:
                return None
            
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª–æ –±—ã –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏
            # –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            confidence = np.random.uniform(0.6, 0.9)
            
            if confidence >= self.config['confidence_threshold']:
                prediction = {
                    'match_id': match['id'],
                    'prediction_type': 'OVER',
                    'confidence': round(confidence, 3),
                    'predicted_line': 54.5,
                    'time_window': 'Q3 Start - Q3 6:00',
                    'expected_value': round(confidence * 0.85, 3)
                }
                return prediction
                
            return None
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è: {e}")
            return None

    async def calculate_stake(self, confidence: float) -> float:
        """–†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ —Å—Ç–∞–≤–∫–∏"""
        base_stake = 0.025
        confidence_multiplier = confidence / 0.7  # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Ä–æ–≥–∞ 0.7
        
        stake = base_stake * confidence_multiplier
        stake = max(self.config['stake_range'][0], 
                   min(stake, self.config['stake_range'][1]))
        
        return round(stake, 4)

    async def save_signal(self, match: Dict, prediction: Dict, stake: float):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –≤ –ë–î"""
        try:
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO ml_q3_over_signals 
                    (match_id, home_team, away_team, league, prediction_type, 
                     confidence, predicted_line, recommended_stake)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    match['id'],
                    match['home_team'],
                    match['away_team'], 
                    match['league'],
                    prediction['prediction_type'],
                    prediction['confidence'],
                    prediction['predicted_line'],
                    stake
                ))
                self.db_conn.commit()
                
            self.logger.info(f"üíæ –°–∏–≥–Ω–∞–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω –¥–ª—è {match['home_team']} vs {match['away_team']}")
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞: {e}")

    async def send_telegram_alert(self, match: Dict, prediction: Dict, stake: float):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram"""
        try:
            message = f"""
üö® *ML THIRD QUARTER OVER SIGNAL*

üèÄ *–ú–∞—Ç—á:* {match['home_team']} vs {match['away_team']}
üìä *–õ–∏–≥–∞:* {match['league']}
üéØ *–ü—Ä–æ–≥–Ω–æ–∑:* OVER {prediction['predicted_line']} –≤ 3-–π —á–µ—Ç–≤–µ—Ä—Ç–∏
‚úÖ *–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å:* {prediction['confidence']:.1%}
üí∞ *–°—Ç–∞–≤–∫–∞:* {stake:.1%} –±–∞–Ω–∫—Ä–æ–ª–ª–∞
‚è∞ *–û–∫–Ω–æ:* {prediction['time_window']}

ü§ñ *–ë–æ—Ç:* {self.bot_name}
            """
            
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª –±—ã –∑–∞–ø—Ä–æ—Å –∫ Telegram API
            self.logger.info(f"üì§ Telegram alert: {message}")
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram: {e}")

    async def check_daily_limit(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ —Å—Ç–∞–≤–æ–∫"""
        try:
            today = datetime.now().date()
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    SELECT COUNT(*) as bet_count 
                    FROM ml_q3_over_signals 
                    WHERE DATE(created_at) = %s AND status = 'active'
                """, (today,))
                result = cursor.fetchone()
                
            current_bets = result[0] if result else 0
            limit_ok = current_bets < self.config['max_daily_bets']
            
            if not limit_ok:
                self.logger.warning(f"‚ö†Ô∏è –î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç: {current_bets}/{self.config['max_daily_bets']}")
                
            return limit_ok
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–∏–º–∏—Ç–∞: {e}")
            return False

    async def process_matches(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ç—á–µ–π"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç
            if not await self.check_daily_limit():
                return
                
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –º–∞—Ç—á–∏
            matches = await self.fetch_live_matches()
            
            signals_generated = 0
            for match in matches:
                try:
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
                    prediction = await self.generate_prediction(match)
                    
                    if prediction:
                        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞–≤–∫—É
                        stake = await self.calculate_stake(prediction['confidence'])
                        
                        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∏–≥–Ω–∞–ª
                        await self.save_signal(match, prediction, stake)
                        
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                        await self.send_telegram_alert(match, prediction, stake)
                        
                        signals_generated += 1
                        self.logger.info(f"‚úÖ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Å–∏–≥–Ω–∞–ª –¥–ª—è {match['home_team']} vs {match['away_team']}")
                        
                except Exception as e:
                    self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ç—á–∞ {match.get('id')}: {e}")
                    continue
            
            self.logger.info(f"üìà –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {signals_generated}")
            
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ç—á–µ–π: {e}")

    async def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –±–æ—Ç–∞"""
        self.logger.info("üéØ –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ ML Third Quarter Over Bot")
        
        while True:
            try:
                start_time = datetime.now()
                
                await self.process_matches()
                
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
                execution_time = (datetime.now() - start_time).total_seconds()
                self.logger.debug(f"‚è±Ô∏è –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ü–∏–∫–ª–∞: {execution_time:.2f}—Å")
                
                # –û–∂–∏–¥–∞–Ω–∏–µ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ü–∏–∫–ª–∞
                await asyncio.sleep(self.config['update_interval'])
                
            except KeyboardInterrupt:
                self.logger.info("üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
                break
            except Exception as e:
                self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {e}")
                await asyncio.sleep(30)  # –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ

    async def shutdown(self):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã"""
        try:
            self.logger.info("üî¥ –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã ML Third Quarter Over Bot...")
            
            if self.db_conn:
                self.db_conn.close()
                self.logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL –∑–∞–∫—Ä—ã—Ç–æ")
                
            self.logger.info("‚úÖ ML Third Quarter Over Bot –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã: {e}")

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞"""
    bot = MLThirdQuarterOverBot()
    
    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        if not await bot.initialize():
            sys.exit(1)
            
        # –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
        await bot.run()
        
    except KeyboardInterrupt:
        bot.logger.info("üõë –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        bot.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        await bot.shutdown()

if __name__ == "__main__":
    asyncio.run(main())
